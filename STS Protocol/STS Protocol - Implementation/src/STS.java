
import java.io.UnsupportedEncodingException;
import java.security.*;
import javax.crypto.BadPaddingException;
import javax.crypto.Cipher;
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.NoSuchPaddingException;
import javax.crypto.spec.SecretKeySpec;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;

class MD5 {
    public static String getMd5(String input) {
        try {

            // Static getInstance method is called with hashing MD5
            MessageDigest md = MessageDigest.getInstance("MD5");

            // digest() method is called to calculate message digest
            //  of an input digest() return array of byte
            byte[] messageDigest = md.digest(input.getBytes());

            // Convert byte array into signum representation
            BigInteger no = new BigInteger(1, messageDigest);

            // Convert message digest into hex value
            String hashtext = no.toString(16);
            while (hashtext.length() < 32) {
                hashtext = "0" + hashtext;
            }
            return hashtext;
        }

        // For specifying wrong message digest algorithms
        catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }

    // Driver code
    public static void main(String args[]) throws NoSuchAlgorithmException {
        String s = "GeeksForGeeks";
        System.out.println("Your HashCode Generated by MD5 is: " + getMd5(s));
    }
} //for hashing

public class STS {
    public static final double primeNumberP = 7;
    public static final double generatorG = 5;

    public static void main(String[] args) throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException, UnsupportedEncodingException {
        // prime=7, generator=5, aliceX=2, bobY=3

        KeyPairGenerator keyGen = KeyPairGenerator.getInstance("DSA", "SUN");

        //Alice
        User Alice = new User("Alice");
        Alice.setRandomValue(2);
        KeyPair pairForAlice = keyGen.generateKeyPair();
        Alice.setPublicKey(pairForAlice.getPublic());
        Alice.setPrivateKey(pairForAlice.getPrivate());

        //Bob
        User Bob = new User("Bob");
        Bob.setRandomValue(3);
        KeyPair pairForBob = keyGen.generateKeyPair();
        Bob.setPublicKey(pairForBob.getPublic());
        Bob.setPrivateKey(pairForBob.getPrivate());


        //=============STEP 1=============
        double exponentialNumberAlice = Alice.getExponential();

        //=============STEP 2=============
        double exponentialNumberBob = Bob.getExponential();
        String keyByBob = Bob.getKey(exponentialNumberAlice);
        String aYaX = Double.toString(exponentialNumberBob) + " " + Double.toString(exponentialNumberAlice);

        //Bob is hashing
        String aYaXHashed = MD5.getMd5(aYaX); //hashing with MD5, I did not found another way

        //Bob is signing
        Cipher c1 = Cipher.getInstance("RSA");
        c1.init(Cipher.ENCRYPT_MODE, Bob.getPrivateKey());
        c1.update(aYaXHashed.getBytes());
        String signedByBob = c1.doFinal().toString();

        //Bob encrypts with shared key
        Cipher c2 = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        SecretKeySpec shared = new SecretKeySpec(keyByBob.getBytes(), "RSA/ECB/PKCS1Padding");
        c2.init(Cipher.ENCRYPT_MODE, shared);
        c2.update(signedByBob.getBytes());
        String encryptedByBob = c2.doFinal().toString();



        //=============STEP 3=============
        String keyByAlice = Alice.getKey(exponentialNumberBob);
        String aXaY = Double.toString(exponentialNumberAlice) + " " + Double.toString(exponentialNumberBob);

        //Alic e is hashing
        String aXaYHashed = MD5.getMd5(aXaY);

        //1.decrypt the whole message
        Cipher c3 = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        SecretKeySpec sharedButByAlice = new SecretKeySpec(keyByAlice.getBytes(), "RSA/ECB/PKCS1Padding");
        c3.init(Cipher.DECRYPT_MODE, sharedButByAlice);
        c3.update(encryptedByBob.getBytes());
        String decryptedByAlice = c3.doFinal().toString();

        //then verify Bob's signature with his public key
        Cipher c4 = Cipher.getInstance("RSA");
        c4.init(Cipher.DECRYPT_MODE, Bob.getPublicKey());
        c4.update(decryptedByAlice.getBytes());
        String verifiedByAlice = c4.doFinal().toString();
        if(verifiedByAlice.equals(signedByBob)){
            System.out.println("Bob really sent the message");
        }

        //then Alice does the same thing

        //Alice is signing
        Cipher c5 = Cipher.getInstance("RSA");
        c5.init(Cipher.ENCRYPT_MODE, Bob.getPrivateKey());
        c5.update(aXaY.getBytes());
        String signedByAlice = c5.doFinal().toString();

        //Bob encrypts with shared key
        Cipher c6 = Cipher.getInstance("RSA/ECB/PKCS1Padding");
        c6.init(Cipher.ENCRYPT_MODE, shared);
        c6.update(signedByAlice.getBytes());
        String encryptedByAlice = c6.doFinal().toString();

        //then verification by Bob...

    }
}

